// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3566.MecanumDriveJan21.commands;

import edu.wpi.first.wpilibj.command.Command;
import navigation.VisionValues;

import org.usfirst.frc3566.MecanumDriveJan21.FishyCam;
import org.usfirst.frc3566.MecanumDriveJan21.Robot;

/**
 *
 */
public class AlignToLiftHook extends Command {
	private boolean finished;

	public static final double STRAFE_POWER = 0.4, ROTATE_POWER = 0.1, FORWARD_POWER = 0.2;
	public static final long TIMER = 50;

	private enum Action {
		TURNING_LEFT, TURNING_RIGHT, STRAFING_LEFT, STRAFING_RIGHT, FORWARD, NA
	}

	private Action action;

	private long endTimer;

	// this is the autonomous command for when there is a lift in front of the
	// robot
	public AlignToLiftHook() {

	}

	protected void initialize() {
		finished = false;
		action = Action.NA;
		endTimer = 0;
	}

	protected void execute() {
		/*
		 * If the vision targets are high enough on the screen, then we're close
		 * enough to finish delivering the gear
		 */
		// FIXME we should maybe pay attention to centering left/right, no?
		if (FishyCam.getCenterY() <= VisionValues.minHeightLiftHookVisionTargets) {
			Robot.mecanumDriveTrain.stopDriveTrain();
			finished = true;

			/*
			 * ...otherwise, we're going to try to get ourselves centered on the
			 * hook while slowly advancing towards it...
			 */
		} else {

			/*
			 * If we aren't in the middle of a maneuver, figure out what we're
			 * going to do next to get centered
			 */
			if (System.currentTimeMillis() >= endTimer) {

				/* If we can see the target... */
				if (FishyCam.isTargetsDetected()) {
					switch (FishyCam.getBearingToTarget()) {
					/*
					 * If we're not centered, strafe until we are...
					 */
					case LEFT:
						Robot.mecanumDriveTrain.driveTrainSidewayLeft(STRAFE_POWER);
						action = Action.STRAFING_LEFT;
						break;
					case RIGHT:
						Robot.mecanumDriveTrain.driveTrainSidewayRight(STRAFE_POWER);
						action = Action.STRAFING_RIGHT;
						break;

					/*
					 * ...but once we're centered, make sure we're flat towards
					 * the target...
					 */
					case CENTER:
					default:
						/*
						 * ...by rotating to adjust the horizon line along the
						 * bottom of the two vision targets (we want a slope of
						 * zero, indicating the two vision targets are
						 * equidistant from us)
						 */
						if (FishyCam.getHorizonSlope() > VisionValues.maxHorizonSlope) {
							Robot.mecanumDriveTrain.rotateLeft(ROTATE_POWER);
							action = Action.TURNING_LEFT;
						} else if (FishyCam.getHorizonSlope() < VisionValues.minHorizonSlope) {
							Robot.mecanumDriveTrain.rotateRight(ROTATE_POWER);
							action = Action.TURNING_RIGHT;

							/*
							 * ...if we're dead-on, advance!
							 */
						} else {
							Robot.mecanumDriveTrain.driveTrainForward(FORWARD_POWER);
							action = Action.FORWARD;
						}
						break;
					}
					endTimer = System.currentTimeMillis() + TIMER;
				}

			} else {
				/*
				 * If we're mid-action, keep doing what we were doing until
				 * we're done!
				 */
				switch (action) {
				case TURNING_LEFT:
					Robot.mecanumDriveTrain.rotateLeft(ROTATE_POWER);
					break;
				case TURNING_RIGHT:
					Robot.mecanumDriveTrain.rotateRight(ROTATE_POWER);
					break;
				case STRAFING_LEFT:
					Robot.mecanumDriveTrain.driveTrainSidewayLeft(STRAFE_POWER);
					break;
				case STRAFING_RIGHT:
					Robot.mecanumDriveTrain.driveTrainSidewayRight(STRAFE_POWER);
					break;
				case FORWARD:
					Robot.mecanumDriveTrain.driveTrainForward(FORWARD_POWER);
					break;
				default:
					// do nothing
				}
			}
		}

	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		// when detected target area is big enough, calls the command to stop
		return finished;
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.mecanumDriveTrain.stopDriveTrain();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		Robot.mecanumDriveTrain.stopDriveTrain();
	}
}
