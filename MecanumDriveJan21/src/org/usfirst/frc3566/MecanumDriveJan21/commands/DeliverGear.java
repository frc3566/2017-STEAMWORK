// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3566.MecanumDriveJan21.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc3566.MecanumDriveJan21.FishyCam;
import org.usfirst.frc3566.MecanumDriveJan21.Robot;
import org.usfirst.frc3566.MecanumDriveJan21.VisionValues;
import org.usfirst.frc3566.MecanumDriveJan21.subsystems.MecanumDriveTrain.Direction;

/**
 *
 */
public class DeliverGear extends Command {
	private boolean finished;

	public static final double STRAFE_POWER = 0.4, ROTATE_POWER = 0.1, FORWARD_POWER = 0.2;
	public static final long TIMER = 50;

	private enum Action {
		TURNING_LEFT, TURNING_RIGHT, STRAFING_LEFT, STRAFING_RIGHT, FORWARD, NA
	}

	private Action action;

	private long endTimer;

	// this is the autonomous command for when there is a lift in front of the
	// robot
	public DeliverGear() {

	}

	protected void initialize() {
		finished = false;
		action = Action.NA;
	}

	protected void execute() {
		if (FishyCam.getCenterY() <= VisionValues.minVerticalBearing) {
			Robot.mecanumDriveTrain.stopDriveTrain();
			finished = true;
			
		} else {

			if (System.currentTimeMillis() >= endTimer) {

				if (FishyCam.isTargetsDetected()) {
					switch (FishyCam.getBearingToTarget()) {
					case LEFT:
						Robot.mecanumDriveTrain.driveTrainSidewayLeft(STRAFE_POWER);
						action = Action.STRAFING_LEFT;
						break;
					case RIGHT:
						Robot.mecanumDriveTrain.driveTrainSidewayRight(STRAFE_POWER);
						action = Action.STRAFING_RIGHT;
						break;
					case CENTER:
					default:
						if (FishyCam.getHorizonSlope() > VisionValues.maxHorizonSlope) {
							Robot.mecanumDriveTrain.rotateLeft(ROTATE_POWER);
							action = Action.TURNING_LEFT;
						} else if (FishyCam.getHorizonSlope() < VisionValues.minHorizonSlope) {
							Robot.mecanumDriveTrain.rotateRight(ROTATE_POWER);
							action = Action.TURNING_RIGHT;
						} else {
							Robot.mecanumDriveTrain.driveTrainForward(FORWARD_POWER);
							action = Action.FORWARD;
						}
						break;
					}
					endTimer = System.currentTimeMillis() + TIMER;
				}
			} else {
				switch (action) {
				case TURNING_LEFT:
					Robot.mecanumDriveTrain.rotateLeft(ROTATE_POWER);
					break;
				case TURNING_RIGHT:
					Robot.mecanumDriveTrain.rotateRight(ROTATE_POWER);
					break;
				case STRAFING_LEFT:
					Robot.mecanumDriveTrain.driveTrainSidewayLeft(STRAFE_POWER);
					break;
				case STRAFING_RIGHT:
					Robot.mecanumDriveTrain.driveTrainSidewayRight(STRAFE_POWER);
					break;
				case FORWARD:
					Robot.mecanumDriveTrain.driveTrainForward(FORWARD_POWER);
					break;
				}
			}
		}

	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		// when detected target area is big enough, calls the command to stop
		return finished;
	}

	// Called once after isFinished returns true
	protected void end() {
		new readyToDeliverCommandGroup().start();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		Robot.mecanumDriveTrain.stopDriveTrain();
	}
}
